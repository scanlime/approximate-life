<!DOCTYPE html>
<html><head><script type="text/javascript">"use strict";
// (C) Micah Elizabeth Scott 2014 - 2021
// Run in Chrome, capture with OBS at 2560x1440

const RESOLUTION = [2560, 1440];
const NUM_BITS = 512;
const WORKER_COUNT = 20;
const JOB_COUNT = 40;
const WORKER_SRC = `
    "use strict";

    // Force model
    const K = 0.1;
    const PRESSURE_K = K * 0.3;
    const TENSION_K = K * 1.0;
    const SURFACE_TENSION_K = TENSION_K * 2.0;
    const RESTING_AREA = 3.0;
    const SIMULATION_STEPS = 400;

    // How large to project our coordinates on the reference image's pixel grid
    const REFERENCE_SCALE = 0.9;

    // Penalty for unused triangles. 1.0 = same as background pixels.
    // Larger values will grow speculatively and avoid overlap, creating
    // space filling curves. Smaller values approaching zero will result in
    // shapes confined to the reference image but not expanding to fill it.
    const UNUSED_TRIANGLE_PENALTY = 0.3;

    // Probability for repeated mutations in a single cycle. >=1.0 will hang.
    const REPEATED_MUTATION_PROBABILITY = 0.6;

    // Size of triangle memo buffer, and maximum size of shapes we can build.
    // Must be a power of two. Determines memory usage per worker.
    const WORLD_SIZE_LOG2 = 9;
    const WORLD_SIZE = 1 << WORLD_SIZE_LOG2;
    const WORLD_SIZE_MASK = WORLD_SIZE - 1;
    const WORLD_AREA = WORLD_SIZE * WORLD_SIZE;

    // Maximum triangle counts, based on maximum bitstream sizes
    const NUM_BITS = 512;
    const MAX_TRIANGLES = NUM_BITS;

    // Amount of simulation detail; each edge is simulated with many intermediate
    // points, to give the cells flexible walls that conform to their surroundings.
    const POINTS_PER_EDGE = 7;
    const MAX_EDGES = MAX_TRIANGLES * 3;
    const POINTS_PER_TRIANGLE = (POINTS_PER_EDGE - 1) * 3;
    const MAX_POINTS = MAX_EDGES * POINTS_PER_EDGE;

    // Generation tags: We use large 32-bit buffers for flags that we need
    // to test and mass-clear often. Instead of physically clearing the memory, we
    // can increment the generation in order to invalidate all previously-marked
    // bits without actually changing the memory.
    var generation = 0;

    // Memo buffer, one uint32 per possible triangle. The coordinate system
    // uses X and Y axes that correspond to two triangle edges. Each grid square
    // consists of two triangles, one at [ (x,y), (x+1,y), (x,y+1) ] and one at
    // [ (x+1,y), (x+1,y+1), (x,y+1) ]. Each grid square has an integer corresponding
    // to a generation number. If the number matches our current generation the triangle
    // is present, otherwise it's absent. This lets us clear the buffer without erasing
    // the entire chunk of memory.
    var triMemo = new Uint32Array(WORLD_AREA * 2);

    // Edge memo: Each (x,y) cell has three possible edges, arranged in the same order
    // as a left-facing triangle (angle 0). Uses the same generation numbers as triMemo.
    var edgeMemo = new Uint32Array(WORLD_AREA * 3);

    // For each edge with a current generation tag in the edgeMemo, the edgeMap gives
    // the index in edgePointIDs / edgeCellCounts.
    var edgeMap = new Uint32Array(WORLD_AREA * 3);

    // Point memo: Each (x,y) cell maps to a generation number, telling us if we've
    // created the point yet. This helps us deduplicate points when mapping from the
    // abstract triangle geometry to our actual points and edges.
    var pointMemo = new Uint32Array(WORLD_AREA);

    // For each point with a current generation tag in the pointMemo, the pointMap
    // gives the index in pointX and pointY corresponding to that triangle vertex.
    var pointMap = new Uint32Array(WORLD_AREA);

    // Map Point ID -> (x, y, type)
    var pointX = new Float64Array(MAX_POINTS);
    var pointY = new Float64Array(MAX_POINTS);
    var pointType = new Uint8Array(MAX_POINTS);

    // Map Edge ID -> Fixed-size list of Point IDs
    var edgePointIDs = new Uint32Array(MAX_POINTS);

    // Edge ID -> Number of cells referencing this edge
    var edgeCellCounts = new Uint8Array(MAX_EDGES);

    // Triangle ID -> Fixed size list of Point IDs in winding order
    var trianglePointIDs = new Uint32Array(MAX_POINTS);

    // Triangle builder state
    var turtleX = null;
    var turtleY = null;
    var turtleA = null;
    var numEdges = null;
    var numPoints = null;
    var numTriangles = null;

    // Reset the state of the triangle builder
    function clear() {
        turtleX = 0;
        turtleY = 0;
        turtleA = 0;
        numEdges = 0;
        numPoints = 0;
        numTriangles = 0;
        generation++;
    }

    // Look for a point at the integer grid location (x, y). Return its ID.
    // Create the point if it doesn't already exist.

    function gridPoint(x, y) {
        var cell = (WORLD_SIZE_MASK & x) | ((WORLD_SIZE_MASK & y) << WORLD_SIZE_LOG2);
        if (pointMemo[cell] == generation) {
            return pointMap[cell];
        }

        pointMemo[cell] = generation;
        var p = numPoints;
        pointMap[cell] = p;

        pointX[p] = x * 0.8660254037844387;   // sqrt(3)/2
        pointY[p] = y + x * 0.5;
        pointType[p] = 0;

        numPoints = p + 1;
        return p;
    }

    // Look up or create an edge. This needs to correlate multiple ways the
    // edge is known: As an arbitrary ID, as the integer coordinates of two
    // endpoints, and as a cell location and direction. The return value is
    // an edge ID for this edge in its canonical direction. Depending on the triangle
    // direction, we may end up using this edge as-is or reversed.

    function edge(cellX, cellY, cellDir, iX1, iY1, iX2, iY2) {
        var cell = cellDir + 3 * ((cellX & WORLD_SIZE_MASK) | ((cellY & WORLD_SIZE_MASK) << WORLD_SIZE_LOG2));
        if (edgeMemo[cell] == generation) {
            return edgeMap[cell];
        }

        edgeMemo[cell] = generation;
        var edge = numEdges;
        edgeMap[cell] = edge;
        edgeCellCounts[edge] = 0;

        var p1 = gridPoint(iX1, iY1);
        var p2 = gridPoint(iX2, iY2);

        // Fill in endpoints
        edgePointIDs[POINTS_PER_EDGE * edge] = p1;
        edgePointIDs[POINTS_PER_EDGE * (edge+1) - 1] = p2;

        // Create unique midpoints. These are not memoized for gridPoint, since
        // they don't correspond to any triangle grid intersections.

        var pointID = numPoints;
        var x1 = pointX[p1];
        var y1 = pointY[p1];
        var xD = pointX[p2] - x1;
        var yD = pointY[p2] - y1;

        for (var i = 1; i < (POINTS_PER_EDGE-1); i++) {
            var t = i / (POINTS_PER_EDGE-1);
            pointX[pointID] = x1 + xD * t;
            pointY[pointID] = y1 + yD * t;
            pointType[pointID] = 1;
            edgePointIDs[POINTS_PER_EDGE * edge + i] = pointID++;
        }

        numPoints = pointID;
        numEdges = edge + 1;
        return edge;
    }

    // Using the current turtle position and current bitstream, create new
    // triangles and update the memo in order to build a shape by interpreting
    // the 1s and 0s in the bitstream as instructions to build left-facing and
    // right-facing triangle geometry.
    //
    // Each bit is an instruction to a virtual turtle:
    //
    //    1) Record the current point
    //    2) Move forward
    //    3) Turn: 1=Right, 0=Left
    //    4) Record the current point
    //    5) Move forward
    //    6) Turn: 1=Right, 0=Left
    //    7) Record the current point
    //    8) Draw a triangle between these three points
    //
    // Duplicate triangles are merged, using the memo buffer.

    function build(bit) {
        // Triangle origin and polarity. Two triangle polarities:
        //    0: [ (x,y), (x+1,y), (x,y+1) ]
        //    1: [ (x,y), (x,y+1), (x-1,y+1) ]
        //
        // These correspond to the triangles you get for the same bit.
        // In fact, these triangles are only produced by the corresponding bit.
        //
        // The identifier we want to build for a triangle is a bitfield:
        //    LSB:                 Triangle polarity
        //    worldSizeLog2 bits:  X coordinate, modulo worldSize
        //    worldSizeLog2 bits:  Y coordinate, modulo worldSize

        var cellX = turtleX, cellY = turtleY;

        // Semantically, we're moving, turning, moving, turning, then drawing
        // a triangle. But we can collapse this into a lookup table of which
        // triangles we end up with for each possible bit and angle. There are
        // only six possibilities.

        if (bit & 1) {    // 1=Right

            if (turtleA == 0) {
                cellX--;
                turtleY++;
                turtleX--;
                turtleA = 2;

            } else if (turtleA == 1) {
                cellX--;
                cellY--;
                turtleY--;
                turtleA = 0;

            } else { // turtleA == 2
                cellY--;
                turtleX++;
                turtleA = 1;
            }

        } else {        // 0=Left

            if (turtleA == 0) {
                turtleX++;
                turtleA = 1;

            } else if (turtleA == 1) {
                cellX--;
                turtleX--;
                turtleY++;
                turtleA = 2;

            } else { // turtleA == 2
                cellY--;
                turtleY--;
                turtleA = 0;
            }
        }

        var tri = (bit & 1) | ((cellX & WORLD_SIZE_MASK) << 1) | ((cellY & WORLD_SIZE_MASK) << (WORLD_SIZE_LOG2+1));
        if (triMemo[tri] != generation) {
            triMemo[tri] = generation;

            var nextPointId = POINTS_PER_TRIANGLE * numTriangles;
            if (bit & 1) {
                // Clockwise / Right / 1 triangle

                var e1 = edge(
                    cellX+1, cellY, 0,
                    cellX+1, cellY, cellX+1, cellY+1);

                var e2 = edge(
                    cellX, cellY+1, 2,
                    cellX+1, cellY+1, cellX, cellY+1);

                var e3 = edge(
                    cellX, cellY, 1,
                    cellX, cellY+1, cellX+1, cellY);

                edgeCellCounts[e1]++;
                edgeCellCounts[e2]++;
                edgeCellCounts[e3]++;

                for (var i = POINTS_PER_EDGE - 1; i; i--) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e3*POINTS_PER_EDGE + i];
                }
                for (var i = POINTS_PER_EDGE - 1; i; i--) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e2*POINTS_PER_EDGE + i];
                }
                for (var i = POINTS_PER_EDGE - 1; i; i--) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e1*POINTS_PER_EDGE + i];
                }

            } else {
                // Counterclockwise / Left / 0 triangle

                var e1 = edge(
                    cellX, cellY, 0,
                    cellX, cellY, cellX, cellY+1);

                var e2 = edge(
                    cellX, cellY, 1,
                    cellX, cellY+1, cellX+1, cellY);

                var e3 = edge(
                    cellX, cellY, 2,
                    cellX+1, cellY, cellX, cellY);

                edgeCellCounts[e1]++;
                edgeCellCounts[e2]++;
                edgeCellCounts[e3]++;

                for (var i = 1; i < POINTS_PER_EDGE; i++) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e1*POINTS_PER_EDGE + i];
                }
                for (var i = 1; i < POINTS_PER_EDGE; i++) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e2*POINTS_PER_EDGE + i];
                }
                for (var i = 1; i < POINTS_PER_EDGE; i++) {
                    trianglePointIDs[nextPointId++] = edgePointIDs[e3*POINTS_PER_EDGE + i];
                }
            }

            // Done building triangle
            numTriangles++;
        }
    }

    // Center the entire drawing's bounding box
    function center() {
        var minX = 1e9, maxX = -1e9, minY = 1e9, maxY = -1e9;
        for (var i = 0; i < numPoints; i++) {
            var x = pointX[i];
            var y = pointY[i];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        var centerX = (minX + maxX) * 0.5;
        var centerY = (minY + maxY) * 0.5;
        for (var i = 0; i < numPoints; i++) {
            pointX[i] = pointX[i] - centerX;
            pointY[i] = pointY[i] - centerY;
        }
    }

    // Simulate the forces acting on the points in this shape,
    // running a number of iterations in succession.
    function simulate() {
        var steps = SIMULATION_STEPS;
        while (steps > 0) {

            // Tension forces along edges
            for (var edge = 0; edge < numEdges; edge++) {

                // How much to contract by
                var f = (edgeCellCounts[edge] == 1 ? SURFACE_TENSION_K : TENSION_K);

                // Iterate over all points in edge
                var begin = edge * POINTS_PER_EDGE;
                var end = begin + POINTS_PER_EDGE;

                var p1 = edgePointIDs[begin];
                var x1 = pointX[p1];
                var y1 = pointY[p1];

                for (var i = begin + 1; i < end; i++) {

                    var p2 = edgePointIDs[i];
                    var x2 = pointX[p2];
                    var y2 = pointY[p2];

                    var dx = f * (x2 - x1);
                    var dy = f * (y2 - y1);

                    pointX[p1] = x1 + dx;
                    pointY[p1] = y1 + dy;
                    x1 = pointX[p2] = x2 - dx;
                    y1 = pointY[p2] = y2 - dy;
                    p1 = p2;
                }
            }

            // Pressure forces in each triangle
            for (var tri = 0; tri < numTriangles; tri++) {

                // Calculate area, walking over all points in the triangle.
                // This calculation gives us 2x the area.
                var area_2x = 0;
                {
                    var begin = tri * POINTS_PER_TRIANGLE;
                    var end = begin + POINTS_PER_TRIANGLE;

                    var p1 = trianglePointIDs[end - 1];
                    var x1 = pointX[p1];  // Loop around
                    var y1 = pointY[p1];

                    for (var i = begin; i < end; i++) {
                        var p2 = trianglePointIDs[i];
                        var x2 = pointX[p2];
                        var y2 = pointY[p2];

                        area_2x += (x1 + x2) * (y1 - y2);

                        x1 = x2;
                        y1 = y2;
                    }
                }

                // Force due to pressure: Resting area / calculated area.
                // Ideal gas law for constant temperature.

                var f = PRESSURE_K * ((RESTING_AREA / area_2x) - 1.0);

                // Apply force normal to each perimeter segment.
                // Includes multiply by segment length.
                {
                    var begin = tri * POINTS_PER_TRIANGLE;
                    var end = (tri + 1) * POINTS_PER_TRIANGLE;

                    var p1 = trianglePointIDs[end - 1];
                    var x1 = pointX[p1];  // Loop around
                    var y1 = pointY[p1];

                    for (var i = begin; i < end; i++) {
                        var p2 = trianglePointIDs[i];
                        var x2 = pointX[p2];
                        var y2 = pointY[p2];

                        var dx = x2 - x1;
                        var dy = y2 - y1;

                        pointX[p1] = x1 - dy * f;
                        pointY[p1] = y1 + dx * f;
                        x1 = pointX[p2] = x2 - dy * f;
                        y1 = pointY[p2] = y2 + dx * f;
                        p1 = p2;
                    }
                }
            }

            steps--;
        }
    }

    var reference = null;
    function calculateScore() {
        var score = 1.0;
        var imageData = reference.imageData;
        for (var i = 0; i < numTriangles; i++) {

            // Centroid for each triangle
            var x = 0;
            var y = 0;
            for (var j = 0; j < POINTS_PER_TRIANGLE; j++) {
                var pt = trianglePointIDs[i * POINTS_PER_TRIANGLE + j];
                x += pointX[pt];
                y += pointY[pt];
            }
            x /= POINTS_PER_TRIANGLE;
            y /= POINTS_PER_TRIANGLE;

            var tx = (REFERENCE_SCALE*x + imageData.width/2)|0;
            var ty = (REFERENCE_SCALE*y + imageData.height/2)|0;
            if (tx >= 0 && ty >= 0 && tx < imageData.width && ty < imageData.height) {
                var pixel = 1 + (tx + ty * imageData.width) * 4;
                var channel = imageData.data[pixel];
                score += channel/255.0;
            } else {
                score += 1.0;
            }
        }
        score += UNUSED_TRIANGLE_PENALTY * (MAX_TRIANGLES - numTriangles);
        return score;
    }

    function mutate(bits) {
        var r = 0;
        do {
            r = Math.random();
            r *= 4;
            switch (r|0) {

                case 0: { // Single bit flip
                    r *= NUM_BITS;
                    bits[(r|0) % NUM_BITS] ^= 1;
                    break;
                }

                case 1: { // Two different bits
                    r *= NUM_BITS;
                    var pt1 = (r|0) % NUM_BITS;
                    r *= NUM_BITS;
                    var pt2 = 1 + ((r|0) % (NUM_BITS - 1));
                    bits[pt1] ^= 1;
                    bits[(pt1 + pt2) % NUM_BITS] ^= 1;
                    break;
                }

                case 2: { // Three different nearby bits
                    r *= NUM_BITS;
                    var pt1 = (r|0) % NUM_BITS;
                    r *= NUM_BITS;
                    var pt2 = 1 + ((r|0) % (NUM_BITS/3));
                    bits[pt1] ^= 1;
                    bits[(pt1 - pt2) % NUM_BITS] ^= 1;
                    bits[(pt1 + pt2) % NUM_BITS] ^= 1;
                    break;
                }

                case 3: { // Copy within, retry on no-op
                    r *= NUM_BITS;
                    var dest = (r|0) % NUM_BITS;
                    r *= NUM_BITS;
                    var src = (dest + 1 + ((r|0) % (NUM_BITS-1))) % NUM_BITS;
                    r *= NUM_BITS-1;
                    var copyLen = (r|0) % Math.min(NUM_BITS - src, NUM_BITS - dest);
                    var saved = bits.toString();
                    bits.copyWithin(dest, src, src + copyLen);
                    if (bits.toString() == saved) {
                        r = 0;
                    }
                    break;
                }
            }
        } while ((r % 1) <= REPEATED_MUTATION_PROBABILITY);
    }

    self.onmessage = function (e) {
        if (e.data.reference) {
            reference = e.data.reference;
        }

        if (e.data.bits) {
            if (e.data.mutate) {
                mutate(e.data.bits);
            }

            clear();
            for (var bit of e.data.bits) {
                build(bit);
            }
            simulate();
            center();

            var response = {
                bits: e.data.bits,
                score: calculateScore(),
            };

            if (e.data.points) {
                response.points = true;
                response.numTriangles = numTriangles;
                response.numEdges = numEdges;
                response.numPoints = numPoints;
                response.pointX = pointX.subarray(0, numPoints);
                response.pointY = pointY.subarray(0, numPoints);
                response.edgePointIDs = edgePointIDs.subarray(0, numEdges * POINTS_PER_EDGE);
                response.trianglePointIDs = trianglePointIDs.subarray(0, numTriangles * POINTS_PER_TRIANGLE);
                response.pointsPerEdge = POINTS_PER_EDGE;
                response.pointsPerTriangle = POINTS_PER_TRIANGLE;
            }

            postMessage(response);
        }
    }
`;

function ReferenceImage() {
    var size = [64, 64];
    var center = [size[0]/2, size[1]/2];

    var canvas = document.createElement('canvas');
    canvas.width = size[0];
    canvas.height = size[1];
    var context = canvas.getContext('2d');

    context.fillStyle = 'white';
    context.fillRect(0, 0, size[0], size[1]);
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.font = 'bold 40px monospace';
    context.fillStyle = 'black';
    context.shadowBlur = 12;
    context.shadowColor = 'black';

    const tracking = 17;
    context.fillText('A', center[0] - tracking, center[1]);
    context.fillText('r', center[0], center[1]);
    context.fillText('t', center[0] + tracking, center[1]);
    this.imageData = context.getImageData(0, 0, size[0], size[1]);
}

function WorkerPool(reference, onmessage) {
    const self = this;
    const workerBlob = new Blob([WORKER_SRC], {type: 'application/javascript'});
    const workerURL = URL.createObjectURL(workerBlob);
    const workers = [];
    var nextWorker = 0;

    for (var i = 0; i < WORKER_COUNT; i++) {
        workers[i] = new Worker(workerURL);
        workers[i].onmessage = onmessage;
        workers[i].postMessage({reference});
    }

    this.submit = function(message) {
        workers[nextWorker].postMessage(message);
        nextWorker = (nextWorker + 1) % WORKER_COUNT;
    }
}

function Bitstream() {
    this.bits = new Uint8Array(NUM_BITS);

    this.toHexString = function() {
        var result = [];
        var digit = NUM_BITS >> 2;
        do {
            digit -= 1;
            var h = 0;
            for (var i = 0; i < 4; i++) {
                h += (this.bits[NUM_BITS-1-(digit*4+i)]&1)<<i;
            }
            result.push(h.toString(16));
        } while (digit > 0);
        return result.join("");
    }

    this.drawPattern = function(context, left, top, width, height) {
        const THICKNESS = 0.4;
        context.fillStyle = '#fff';
        var bitWidth = width / NUM_BITS;
        var bitThickness = bitWidth * THICKNESS;
        for (var i = 0; i < NUM_BITS; i++) {
            var bitHeight = (1 & this.bits[i]) ? height : bitThickness;
            context.fillRect(bitWidth*(i+0.5-THICKNESS*0.5), top+height-bitHeight, bitThickness, bitHeight);
        }
    }
}

function Renderer(canvas) {
    canvas.width = RESOLUTION[0];
    canvas.height = RESOLUTION[1];
    this.canvas = canvas;
    var context = canvas.getContext('2d');

    const SCALE = 40;
    const CENTER_X = 0.5;
    const CENTER_Y = 0.48;
    const TRIANGLE_FILL_STYLE = 'rgba(255,40,200,0.3)';
    const EDGE_STROKE_STYLE = '#e5cbe3';
    const EDGE_STROKE_WIDTH = 0.055;
    const GHOST_STROKE_STYLE = '#fff';
    const GHOST_STROKE_WIDTH = 0.1;
    const GHOST_FADE_RATE = 0.08;
    const BORDER_STROKE_STYLE = '#131916';
    const BORDER_STROKE_WIDTH = 4.0;
    const ROLLING_CHART_OPACITY = 0.2;

    this.drawEdgePaths = function(state) {
        var index = 0;
        for (var i = 0; i < state.numEdges; i++) {
            context.beginPath();
            for (var j = 0; j < state.pointsPerEdge; j++) {
                var p = state.edgePointIDs[index++];
                context.lineTo(state.pointX[p], state.pointY[p]);
            }
            context.stroke();
        }
    }

    this.drawTrianglePaths = function(state) {
        var index = 0;
        for (var i = 0; i < state.numTriangles; i++) {
            context.beginPath();
            for (var j = 0; j < state.pointsPerTriangle; j++) {
                var p = state.trianglePointIDs[index++];
                context.lineTo(state.pointX[p], state.pointY[p]);
            }
            context.closePath();
            context.fill();
        }
    }

    this.clear = function() {
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    this.ghostFrame = function(state) {
        context.fillStyle = 'rgba(0,0,0,' + GHOST_FADE_RATE + ')';
        context.fillRect(0, 0, canvas.width, canvas.height);

        context.setTransform(SCALE, 0, 0, SCALE, canvas.width * CENTER_X, canvas.height * CENTER_Y);
        context.strokeStyle = GHOST_STROKE_STYLE;
        context.lineWidth = GHOST_STROKE_WIDTH;
        context.lineCap = 'round';
        this.drawEdgePaths(state);
        context.setTransform(1,0,0,1,0,0);
    }

    this.solidFrame = function(state) {
        context.setTransform(SCALE, 0, 0, SCALE, canvas.width * CENTER_X, canvas.height * CENTER_Y);

        context.strokeStyle = BORDER_STROKE_STYLE;
        context.lineWidth = BORDER_STROKE_WIDTH;
        context.lineCap = 'round';
        this.drawEdgePaths(state);

        context.fillStyle = TRIANGLE_FILL_STYLE;
        this.drawTrianglePaths(state);

        context.strokeStyle = EDGE_STROKE_STYLE;
        context.lineWidth = EDGE_STROKE_WIDTH;
        context.lineCap = 'round';
        this.drawEdgePaths(state);

        context.setTransform(1,0,0,1,0,0);
    }

    this.infoFrame = function(e) {
        var scrollHeight = canvas.height - 155;
        var scrollRate = 1.0;
        var patternY = canvas.height - 148;

        // Copy a new row from the pattern drawing into the rolling chart
        context.globalAlpha = ROLLING_CHART_OPACITY;
        context.drawImage(e.previousFrame, 0, patternY, canvas.width, scrollRate, 0, scrollHeight - scrollRate, canvas.width, scrollRate);
        context.globalAlpha = 1.0;

        // Scroll the bulk of the rolling chart
        context.drawImage(e.previousFrame, 0, scrollRate, canvas.width, scrollHeight, 0, 0, canvas.width, scrollHeight);

        e.bitstream.drawPattern(context, 0, patternY, canvas.width, 50);

        context.fillStyle = 'rgba(255,255,255,0.5)';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.font = '36.1px "Consolas"';
        context.fillText(e.bitstream.toHexString(), canvas.width/2, canvas.height - 62);

        context.fillStyle = 'rgba(255,255,255,0.3)';
        context.font = '30px "DIN Condensed"';
        context.textAlign = 'left';
        context.fillText("MES 2014-2021  //  TRI-" + NUM_BITS, 8, canvas.height - 16);
        context.textAlign = 'right';
        context.fillText("#" + e.responseCount, canvas.width - 8, canvas.height - 16);
    }
}

function main() {
    const GHOST_MAX_FPS = 30.0;
    const SCORE_RATIO_THRESHOLD = 1.008;
    const WARMUP_COUNT = 8000;

    var infoLayers = [
        new Renderer(document.getElementById('info0Layer')),
        new Renderer(document.getElementById('info1Layer')),
    ];
    var midLayer = new Renderer(document.getElementById('midLayer'));
    var ghostLayer = new Renderer(document.getElementById('ghostLayer'));

    var reference = new ReferenceImage();
    var bitstream = new Bitstream();

    var bestResponse = null;
    var ghostResponse = null;
    var responseCount = 0;
    var infoLayerToggle = 0;

    var pool = new WorkerPool(reference, function (e) {
        responseCount++;

        var goodScore = bestResponse == null || (e.data.score / bestResponse.score < SCORE_RATIO_THRESHOLD);
        var wantPoints = ghostResponse == null || goodScore;

        if (wantPoints && !e.data.points) {
            // Run this one again, but request the points
            pool.submit({
                bits: e.data.bits,
                points: true,
                mutate: false,
            });
        } else {

            if (ghostResponse == null && e.data.points) {
                ghostResponse = e.data;
            }

            if (goodScore && e.data.points) {
                bestResponse = e.data;
                bitstream.bits.set(e.data.bits);
                midLayer.clear();
                midLayer.solidFrame(bestResponse);
                infoLayers[infoLayerToggle].infoFrame({
                    previousFrame: infoLayers[infoLayerToggle^1].canvas,
                    responseCount: Math.max(0, responseCount - WARMUP_COUNT),
                    bitstream
                });
                infoLayerToggle ^= 1;
                infoLayers[infoLayerToggle].clear();
            }

            pool.submit({
                bits: bestResponse.bits,
                points: false,
                mutate: responseCount > WARMUP_COUNT,
            });
        }
    });

    for (var i = 0; i < JOB_COUNT; i++) {
        pool.submit({
            bits: bitstream.bits,
            points: true,
            mutate: false,
        });
    }

    window.setInterval(function () {
        if (ghostResponse) {
            ghostLayer.ghostFrame(ghostResponse);
            ghostResponse = null;
        }
    }, 1000 / GHOST_MAX_FPS);
}

</script>
<style type="text/css">
    body {
        background: #800;
        overflow: hidden;
    }
    canvas  {
        position: absolute;
        top: 0;
        left: 0;
    }
    #info0Layer {
        background: #192822;
    }
    #ghostLayer {
        mix-blend-mode: lighten;
        opacity: 0.2;
    }
</style>
</head>
<body onload="main()">
    <canvas id="info0Layer"></canvas>
    <canvas id="info1Layer"></canvas>
    <canvas id="midLayer"></canvas>
    <canvas id="ghostLayer"></canvas>
</body>
</html>
